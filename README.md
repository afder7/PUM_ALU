# Эмулятор АЛУ

## Предисловие

Данное задание практикума станет иллюстрацией того, как работает [арифметико-логическое устройство](https://ru.wikipedia.org/wiki/Арифметико-логическое_устройство) процессора. В процессе его выполнения, начав с моделирования простейших логических схем (в учебнике им посвыящен параграф 23), вы придете к модели устройства, способного сравнить, и сложить два 8-битных целых числа, а также произвести с ними побитовые операции алгебры логики. Главное отличие модели от реального АЛУ современного процессора -- разрядность машинного слова. Наша задача -- понять основные принципы функционирования компьютера, а 8-битных регистров для этого вполне достаточно.

Основная часть кода в данном задании уже написана: это код самой системы моделирования. Попробуйте понять, как она устроена, какова ее архитектура. Подобные архитектуры вы встретите в "боевых" программах. Основная задача данной архитектуры -- предоставить учащимся удобную систему моделирования, в которой не требуется производить лишних телодвижений при проектировании логических схем. В ней автор использовал "потаенные" возможности языка, о которых не рассказывалось на уроке. Но главное, что выполнять данное задание можно и без понимания того, как устроена сама система моделирования.

Помимо значительной части кода, задание содержит подробную инструкцию по его выполнению, чтобы учащиеся могли сконцентрироваться на творческом процессе изобретения логических схем.

## Инструкция

### Стрктура задания

Программа состоит из нескольких файлов. Создавать новые файлы нельзя. Вот их небольшое описание:
- test.py: Файл, содержащий тесты программы. Они запускаются автоматически при помощи Gitlab CI и осуществляют автоматическую проверку ваших решений. Сейчас тесты не проходят, ваша оценка будет зависеть от количества тестов, которые успешно пройдут.
- lib/core.py: Файл, содержащий абстракции самого низкого уровня, такие как контакт и проводник.
- lib/utils.py: Файл, содержащий вспомогательные конструкции
- lib/circuit.py: Основной файл задания, содержащий модели базовых элементов NOT, AND, OR. Именно в этот файл вам неоходимо вносить изменения.

### Рамки дозволенного

Данное задание практикума имеет одну особенность, отличающую его от большинства других. Его основной фокус не заключается в развитии у учащихся навыка программирования: задание стремится объяснить учащимся, как устроен компьютер. Есть ряд ограничений, которые требуется соблюдать при выполнении задания:
1. Вносить изменения разрешается только в файл `lib/circuit.py`.
2. Можно создавать новые классы, унаследованные от класса `Circuit`.
3. В существующих классах, или классах, созданных самостоятельно РАЗРЕШАЕТСЯ:
    - Переопределять переменную `ELEMENTS`. Она всегда должна иметь вид словаря, ключами которого являются классы элементов, используемых в логической схеме, значения -- списки или кортежи, содержащие названия конкретных элементов. Это те имена, при помощи которых вы будете обращаться к конкретным элементам.
    - Переопределять функцию `inout`. Данная функция НЕ ДОЛЖНА производить никаких вычислений. Она должна иметь единственную инструкцию: возвращать словарь, объясняющий соответсвие между входами схемы и входами элементов (задекларированных в `ELEMENTS`) внутри нее, а также выходами схемы и соответствующих выходов элементов этой схеме. Входы должны называться `in1`, `in2`, `in3` и так далее, выходы: `out1`, `out2`, `out3` и так далее. Если нарушить это правило, тесты проходить **не будут**. Важно, что один вход схемы нельзя назначить входам нескольких элементов. Чтобы разрешить эту ситуацию, введен элемент `Bridge`. У него один вход и один выход. Его вход необходимо поставить в соответствие одному из входов схемы, а выход соединить со входами других элементов при помощи проводника в функции `connect`.
    - Переопределять функцию `connect`. Данная функция НЕ ДОЛЖНА производить никаких вычислений. Она должна иметь единственную инструкцию: возвращать кортеж кортежей, каждый из которых описывает один проводник (в кортеже должен быть список контактов, которые проводник соединяет). В кортеже не должно быть более одного выводного контакта (out), при этом может быть любое количесвто вводных контактов (in). Обратите внимание что вот это: `(x)` -- не кортеж, а вот это: `(x,)` -- уже кортеж.
4. Никаких иных изменений в код вносить нельзя. Обратите внимание, что запрещено использовать переменные, арифметические и логические операции, конструкции ветвления и циклов и так далее.

### Пример реализации логической схемы

Давайте рассмотрим класс NOR в файле `lib/circuit.py`. Этот класс реализует логическую схему со следующей таблицей истинности:
```
a b NOR
0 0 1
0 1 0
1 0 0
1 1 0
```
Приблизительно так может выглядеть чертеж этой схемы: ![NOR](nor.png)

1. Данная схема состоит из двух базовых элементов: NOT и OR. Поэтому в словаре `ELEMENTS` мы заводим переменные этих классов с именами `n1` и `o1` соответственно.
2. Данная схема содержит два входа и один выход, оба ее входа мы направляем на входы элемента `o1`, а выход элемента `n1` мы направляем на выход самой этой схемы.
3. Все, что нам осталось -- соединить `o1` и `n1` между собой. Это мы сделаем в функции `connect`, соединив выход `o1` со входом `n1`.

Наша схема готова, она проходит тесты.

### Задание на "3"

На тройку необходимо реализовать базовые схемы алгебры логики. Описание этих заданий будет содержать название класса и таблицу истинности.

1. NAND
```
a b NAND
0 0 1
0 1 1
1 0 1
1 1 0
```

2. XOR
```
a b XOR
0 0 0
0 1 1
1 0 1
1 1 0
```

3. AND3
```
a b c AND3
0 0 0 0
0 0 1 0
0 1 0 0
0 1 1 0
1 0 0 0
1 0 1 0
1 1 0 0
1 1 1 1
```

4. OR3
```
a b c OR3
0 0 0 0
0 0 1 1
0 1 0 1
0 1 1 1
1 0 0 1
1 0 1 1
1 1 0 1
1 1 1 1
```

5. XNOR
```
a b XNOR
0 0 1
0 1 0
1 0 0
1 1 1
```

### Задание на "4"

На "4" необходимо выполнить все, требующееся на "3". Помимо этого, придется поработать над несколькими нетривиальными схемами.

1. ODD. Эта схема выдает 1, если сигнал 1 поступил на нечетное количество входов, иначе 0.
```
a b c d ODD
0 0 0 0 0
0 0 0 1 1
0 0 1 0 1
0 0 1 1 0
0 1 0 0 1
0 1 0 1 0
0 1 1 0 0
0 1 1 1 1
1 0 0 0 1
1 0 0 1 0
1 0 1 0 0
1 0 1 1 1
1 1 0 0 0
1 1 0 1 1
1 1 1 0 1
1 1 1 1 0
```

2. MT1. Эта схема выдает 1, если на 2-х, 3-х или на всех входах был подан сигнал 1, иначе 0.
```
a b c d MT1
0 0 0 0 0
0 0 0 1 0
0 0 1 0 0
0 0 1 1 1
0 1 0 0 0
0 1 0 1 1
0 1 1 0 1
0 1 1 1 1
1 0 0 0 0
1 0 0 1 1
1 0 1 0 1
1 0 1 1 1
1 1 0 0 1
1 1 0 1 1
1 1 1 0 1
1 1 1 1 1
```

3. SC. У схемы 3 входа и 4 выхода. Она подсчитывает количество 1 на входах и выдает 1 на соответствующем выходе.
```
a b c SC0 SC1 SC2 SC3
0 0 0 1   0   0   0
0 0 1 0   1   0   0
0 1 0 0   1   0   0
0 1 1 0   0   1   0
1 0 0 0   1   0   0
1 0 1 0   0   1   0
1 1 0 0   0   1   0
1 1 1 0   0   0   1
```

4. HADD. Данная схема реализует сложение двух битов (a и b). Возвращает значение суммы (S) и переноса (C).
```
a b S C
0 0 0 0
0 1 1 0
1 0 1 0
1 1 0 1
```

5. ADD. Данная схема реализует сложение двух битов (a и b) с переносом (c). Возвращает значение суммы (S) и переноса (C).
```
a b c S C
0 0 0 0 0
0 0 1 1 0
0 1 0 1 0
0 1 1 0 1
1 0 0 1 0
1 0 1 0 1
1 1 0 0 1
1 1 1 1 1
```

### Задание на "5"

На "5" необходимо выполнить все, что требуется на "3" и на "4". Помимо этого, потребуется немного поработать с байтами. Байтовые схемы будут иметь большое количество входов и выходов, т.к. на каждый байт их потребуется 8. Далее таблиц истинности не будет, задания будут сформулированы словесно.

1. NOT8. Имеет 8 входов и 8 выходов. Осуществляет побитовое NOT для 8-битного числа.
2. OR8. Имеет 16 входов и 8 выходов. Первые 8 входов -- первое число, следующие 8 -- второе число. На выходе схема формирует побитовый OR двух чисел.
3. AND8. Схема, аналогичная OR8, но на выходе должен быть побитовый AND.
4. EQ8. Имеет 16 входов и 1 выход. Схема проверяет, равны ли два числа на входах. Если да, возвращает 1, иначе 0.
5. NEQ8. Имеет 16 входов и 1 выход. Схема проверяет, равны ли два числа на входах. Если да, возвращает 0, иначе 1.
6. GT8. Имеет 16 входов и 1 выход. Схема проверяет, верно ли, что первое число больше второго. Если да, возвращает 1, иначе 0.
7. LT8. Имеет 16 входов и 1 выход. Схема проверяет, верно ли, что первое число меньше второго. Если да, возвращает 1, иначе 0.
8. GTE8. Имеет 16 входов и 1 выход. Схема проверяет, верно ли, что первое число больше или равно второму. Если да, возвращает 1, иначе 0.
9. LTE8. Имеет 16 входов и 1 выход. Схема проверяет, верно ли, что первое число меньше или равно второму. Если да, возвращает 1, иначе 0.
10. ADD8. Складывает два байта. Имеет 16 входов и 9 выходов. Первые 8 выходов -- сумма двух чисел, 9-й выход -- значение переноса.

### Задание на дополнительную "5" с коэффициентом 1

Все представленные операции можно объединить в одной схеме, это так называемое арифметико-логическое устройство. Обычно оно также умеет делить и умножать, но мы оставим эти операции за рамками нашего курса.

ALU. Имеет 20 входов и 9 выходов. Первые 4 входа кодируют одну из операций по следующей схеме:
```
0 0 0 0 -- NOT8
0 0 0 1 -- OR8
0 0 1 0 -- AND8
0 0 1 1 -- EQ8
0 1 0 0 -- NEQ8
0 1 0 1 -- GT8
0 1 1 0 -- LT8
0 1 1 1 -- GTE8
1 0 0 0 -- LTE8
1 0 0 1 -- ADD8
```

Следующие 16 бит содержат одно или два целых числа. Если результатом операции является один бит, он должен быть подан на out1. Если результат -- 8 бит, он должен лежать в out1 - out8, если это операция сложения, то результат должен быть в out1 - out8, перенос -- в out9.
